package main
//import all dependencies
import (
	"context"
	"fmt"
	"log"
	"os"
	"strconv"
	"math/rand"
	"strings"
	"time"

	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"github.com/joho/godotenv"
	"github.com/gin-gonic/gin"
	"go.mongodb.org/mongo-driver/bson"

)

//structs

type Response struct { 
	Name string `json:"name"`//e.g. "name":"Ho Yeung"
	Answer []string `json:"answer"` // store the answer of all questions e.g. "answer":["Tutorial", "red", "satisfied", "good"]
	Time string `json:"time"` // store the time of responses
}

type Question struct {
	Question string `json:"question"` //question title
	QuestionFormat string `json:"question_format" bson:"questionFormat"` // "Textbox" / "Multiple Choice" / "Likert Scale"
	Specification []string `json:"specification"`
}

type Survey struct {
	ID string `bson:"_id,omitempty"` //will be auto generated by mongodb
	Title string `json:"title"` //survey title
	Token string `json:"token"` //random, not repeated, 5 char letter&no
	Questions []Question `json:"questions"`
	Time string `json:"time,omitempty"` //time of the survey created
	LastModifiedTime string `json:"last_modified_time,omitempty" bson:"lastModifiedTime"` //time of the survey last modified
	Responses []Response `json:"responses,omitempty"` //not create the responses field first
}

type SurveyWithResponses struct { //for displaying surveys that hv responses
	ID string `bson:"_id,omitempty"`
	Title string `json:"title"` //survey title
	Token string `json:"token"`
	Questions []Question `json:"questions"`
	Responses []Response `json:"responses"`
}

type EditQuestion struct { //for editing surveys
	Question string `json:"question"`
	QuestionFormat string `json:"question_format" bson:"questionFormat"`
	Specification []string `json:"specification"`
}

//for displaying mode of response equal to individual 

type QuestionAnswer struct {
	Question string `json:"question"` //question title
	Answer string `json:"answer"` //answer of the question
}

type IndividualResponses struct {
	Name string `json:"name"` //name of the responder
	QA []QuestionAnswer `json:"qa"`
	Time string `json:"time"` //time of the response
}

type FormattedIndividualResponses struct {
	Title string `json:"title"`
	Responses []IndividualResponses `json:"responses"`
}

//for displaying mode of response equal to overview 

type OverviewQuestions struct {
	Question string `json:"question"` //question title
	Answer []string `json:"answer"` //all answers, e.g. ["red (5,XX%)", "blue (8,XX%)", "green (1,XX%)"]
}
type FormattedOverviewResponses struct {
	Title string `json:"title"`
	NumberOfResponses int `json:"number_of_responses"` //no. of responses
	Questions []OverviewQuestions `json:"questions"`
}

// global variable for the mongodb collection, so all api can access the collection
var surveysCollection *mongo.Collection

//generate random token when creating a new survey
func generateRandomToken() string {
	//string containing all letters and numbers
	const combination = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
	const tokenLength = 5

	token := make([]byte, tokenLength) //make an empty byte array
	for i := range token {
		randIndex := rand.Intn(len(combination)) //make a random index
		token[i] = combination[randIndex] //choose it from the combination arr
	} //e.g. {"d","w","2","a","3"}

	//transform the byte array into a string arr and join all elements
	return strings.Join([]string{string(token)}, "") //e.g. dw2a3
}

//validate questions
func validateQuestions(questions []Question, c*gin.Context) error {
	//check no empty survey
	if len(questions)< 1 {
		c.JSON(400, gin.H{"error": "Cannot be an empty survey"})
		return fmt.Errorf("Cannot be an empty survey") //return an error, preventing return nil
	}		

	for i := range questions { //loop all questions to check
		//check question title
		if (len(questions[i].Question) < 3) {
			c.JSON(400, gin.H{"error": "The question title should have at least 3 characters"})
			return fmt.Errorf("The question title should have at least 3 characters")
		}
		//check if the question format is valid, question format should be "Textbox", "Multiple Choice" or "Likert Scale"
		if (questions[i].QuestionFormat != "Textbox" && questions[i].QuestionFormat != "Multiple Choice" && questions[i].QuestionFormat != "Likert Scale") {
			c.JSON(400, gin.H{"error": "Invalid question format"})
			return fmt.Errorf("Invalid question format")
		}
		if questions[i].QuestionFormat == "Textbox" {
			if (len(questions[i].Specification) > 0) {
				c.JSON(400, gin.H{"error": "Textbox format should not have specification"})
				return fmt.Errorf("Textbox format should not have specification")
			}
		} else if (questions[i].QuestionFormat == "Multiple Choice") {
			//check the array have at least 2 elements
			if len(questions[i].Specification) < 2 {
				c.JSON(400, gin.H{"error": "Multiple Choice question should have at least 2 options"})
				return fmt.Errorf("Multiple Choice question should have at least 2 options")
			}
		} else { //Likert Scale
			//check the array have at least 3 elements
			if len(questions[i].Specification) < 3 {
				c.JSON(400, gin.H{"error": "Likert Scale should have at least 3 options"})
				return fmt.Errorf("Likert Scale should have at least 3 options")
			}
		}
	}

	return nil //no error
}

//check token
func checkToken(token string, c*gin.Context) error {
	// check whether the token is valid i.e. length is 5 and not include any special characters
	if ((len(token) != 5) || (strings.ContainsAny(token, "!@#$%^&*()_+{}|:<>?~`-=[]\\;',./"))) {
		c.JSON(400, gin.H{"error": "Invalid token"})
		return fmt.Errorf("Invalid token")
	}
	return nil
}

//check survey title
func checkTitle(title string, c*gin.Context) error {
	//check title is not exist
	count, err := surveysCollection.CountDocuments(context.TODO(), bson.M{"title": title})
	if err != nil {
		c.JSON(500, gin.H{"error": "Failed to check the survey title"})
		return fmt.Errorf("Failed to check the survey title")
	}
	if count > 0 { // title is not unique
		c.JSON(400, gin.H{"error": "The Survey Title already exists"})
		return fmt.Errorf("The Survey Title already exists")
	}

	if (len(title) < 2) || (len(title) > 300) { //title should be 2 to 300 char
		c.JSON(400, gin.H{"error": "The Survey title should be 2 to 300 characters"})
		return fmt.Errorf("The Survey title should be 2 to 300 characters")
	}
	return nil
}

func main() {

	err := godotenv.Load(".env") //load .env for confidential data i.e. username & pwd of db
	if err != nil {
	  log.Fatalf(".env file cannot be loaded")
	}

	// connect to mongodb
	opt := options.Client().ApplyURI("mongodb://localhost:27017/?connect=direct").SetAuth(options.Credential{ //connect local db
		Username: os.Getenv("DB_USERNAME"),//retrieve from .env
		Password: os.Getenv("DB_PASSWORD"),
		AuthSource: "admin",
		AuthMechanism: "SCRAM-SHA-256", //use sha256 to encrypt the password
	})

	// create a new client and connect to the server
	client, err := mongo.Connect(context.TODO(), opt)
	if err != nil {
		log.Fatal(err)
	}

	surveysCollection = client.Database("OSP").Collection("Survey")

	// check the connection
	err = client.Ping(context.TODO(), nil)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println("Connected to MongoDB!")

	router := gin.Default()

// create a new survey 
	router.POST("/surveys", func(c *gin.Context) {
		var survey Survey
		if err := c.BindJSON(&survey); err != nil { //combining the request body with the survey object
			c.JSON(400, gin.H{"error": "Invalid input"})
			return
		}

		//check survey's title
		if checkTitle(survey.Title, c) != nil {
			return
		}

		//check token is not repeated, else gen a new one
		var tempIteration int = 0 //to prevent infinite loop

		for (true) {
			survey.Token = generateRandomToken()

			// check whether the token already exists by counting the token
			count, err := surveysCollection.CountDocuments(context.TODO(), bson.M{"token": survey.Token})
			if err != nil {
				c.JSON(500, gin.H{"error": "Failed to check token"})
				return
			}

			if count == 0 { // token is unique, stop iterating
				break
			}

			if (tempIteration > 100) { //if the token is not unique for 100 times, break the loop
				c.JSON(500, gin.H{"error": "Failed to generate a unique token"})
				return
			}
			tempIteration++
		}

		//check all questions
		if (validateQuestions(survey.Questions, c)) != nil {
			return //hv error
		}

		//get the current time, the format must be set to this one, else will not work
		survey.Time = time.Now().Format("2006-01-02 15:04:05") //time of the survey created
		survey.LastModifiedTime = survey.Time //time of the survey last modified

		//set the responses to be empty
		survey.Responses = []Response{}

		// insert the survey into the database
		_, err := surveysCollection.InsertOne(context.TODO(), survey)
		if err != nil {
			c.JSON(500, gin.H{"error": "Failed to create survey"})
			return
		}
		
		c.JSON(200, gin.H{"message": fmt.Sprintf("Survey successfully created. The token of this survey is: %s", survey.Token)}) //show the survey token

	})

	// display a new survey using the input token
	router.GET("/surveys/:token", func(c *gin.Context) {
		token := c.Param("token") // Get the input token
		if checkToken(token,c) != nil {
			return
		}

		var survey Survey
		
		err := surveysCollection.FindOne(context.TODO(), bson.M{"token": token}).Decode(&survey) // search survey with that token, assign it to the empty survey obj
		if err != nil {
			c.JSON(404, gin.H{"error": "Survey not found"})
			return
		}
		// return the survey title & questions
		c.IndentedJSON(200, gin.H{"questions": survey.Questions, "title": survey.Title}) //IndentedJSON is for prettier output
	})

// edit a survey in all fields
	router.PUT("/surveys/:token", func(c *gin.Context) {
		token := c.Param("token") // get the input token
		if checkToken(token,c) != nil {
			return
		}

		var survey Survey

		err := surveysCollection.FindOne(context.TODO(), bson.M{"token": token}).Decode(&survey) // search survey
		if err != nil {
			c.JSON(404, gin.H{"error": "Survey not found"})
			return
		}

		if err := c.BindJSON(&survey); err != nil {
			c.JSON(400, gin.H{"error": "Invalid input"})
			return
		}

		//check survey title
		if checkTitle(survey.Title, c) != nil {
			return
		}

		//check all questions
		if (validateQuestions(survey.Questions, c)) != nil {
			return
		}

		//All responses will be deleted if the survey is updated, preventing unmatched questions and responses
		survey.Responses = []Response{} //set the responses to be empty

		survey.LastModifiedTime = time.Now().Format("2006-01-02 15:04:05")  //update the time of the survey last modified

		// update this survey in the db

		_, err = surveysCollection.UpdateOne(context.TODO(), 
			bson.M{"token": token}, 
			bson.M{"$set": bson.M{"title": survey.Title, "questions": survey.Questions, "lastModifiedTime": survey.LastModifiedTime, "responses": survey.Responses }}) //update title and question arr in the survey with that token

		if err != nil {
			c.JSON(500, gin.H{"error": "Failed to update survey"})
			return
		}
		c.JSON(200, gin.H{"message": "Survey successfully updated"})
		
	})

//edit a question
	router.PUT("/surveys/:token/:questionNo", func(c *gin.Context) {
		token := c.Param("token") // get the input token
		if checkToken(token,c) != nil {
			return
		}

		var survey Survey

		err := surveysCollection.FindOne(context.TODO(), bson.M{"token": token}).Decode(&survey) // search survey
		if err != nil {
			c.JSON(404, gin.H{"error": "Survey not found"})
			return
		}

		var editQuestion EditQuestion
		if err := c.BindJSON(&editQuestion); err != nil { //combine req. body with editQuestion
			c.JSON(400, gin.H{"error": "Invalid input"})
			return
		}

		questionNo, err := strconv.Atoi(c.Param("questionNo")) // get the question number string -> int
		if err != nil || questionNo <= 0 || questionNo > len(survey.Questions) {
			c.JSON(400, gin.H{"error": "Invalid question number"})
			return
		}

		arrIndex := questionNo - 1 //e.g. Q1 is at Questions[0]

		survey.Questions[arrIndex].Question = editQuestion.Question
		survey.Questions[arrIndex].QuestionFormat = editQuestion.QuestionFormat
		survey.Questions[arrIndex].Specification = editQuestion.Specification

		//check all questions
		if (validateQuestions(survey.Questions, c)) != nil {
			return
		}

		if(survey.Responses != nil) { //if the survey has no responses, no need to delete the responses
			//All responses of this question will be deleted, preventing unmatched responses
			for i := range survey.Responses { //loop all responses
				survey.Responses[i].Answer[arrIndex] = "Deleted" //set the answer of this question to be "Deleted"
			}
		}

		survey.LastModifiedTime = time.Now().Format("2006-01-02 15:04:05")  //update the time of the survey last modified

		// update in the database
		_, err = surveysCollection.UpdateOne(context.TODO(),
			bson.M{"token": token}, 
			bson.M{"$set": bson.M{"questions": survey.Questions, "lastModifiedTime": survey.LastModifiedTime, "responses": survey.Responses}}) //update the question arr which has one edited question

		if err != nil {
			c.JSON(500, gin.H{"error": "Failed to update a question"})
			return
		}
		c.JSON(200, gin.H{"message": "The survey question successfully updated"})
	})

//insert a question e.g. questionNo = 2, insert a question between persent Q1 & Q2
	router.POST("/surveys/:token/:questionNo", func(c *gin.Context) {
		token := c.Param("token") // get the input token
		if checkToken(token,c) != nil {
			return
		}
		var survey Survey
		err := surveysCollection.FindOne(context.TODO(), bson.M{"token": token}).Decode(&survey) // search survey
		if err != nil {
			c.JSON(404, gin.H{"error": "Survey not found"})
			return
		}

		insertQuestionNo := c.Param("questionNo")
		questionNo, err := strconv.Atoi(insertQuestionNo) // get the question number string -> int

		if err != nil || questionNo <= 0 || questionNo > len(survey.Questions) + 1 { //question should >= 1, question no. should not exceed total no. of questinos + 1
			c.JSON(400, gin.H{"error": "Invalid question number"})
			return
		}

		arrIndex := questionNo - 1 //e.g. Q1 is at Questions[0]
		var newQuestion Question
		if err := c.BindJSON(&newQuestion); err != nil { //combine req. body with newQuestion
			c.JSON(400, gin.H{"error": "Invalid input"})
			return
		}

		if validateQuestions([]Question{newQuestion}, c) != nil { //check the new question by putting it into a arr
			return
		} 

		//insert the new question into the Questions array

		//if the questionNo is 1, insert the new question at the beginning
		if arrIndex == 0 {
			survey.Questions = append([]Question{newQuestion}, survey.Questions...)
			//put all existed responses to the back, added "No answer" to the new question
			for i := range survey.Responses { //loop all responses
				survey.Responses[i].Answer = append([]string{"No answer"}, survey.Responses[i].Answer...)
			}
		} else if arrIndex == len(survey.Questions) { //if the questionNo is the last question, just append it to the array
			survey.Questions = append(survey.Questions, newQuestion)
			//append "No answer" to the new question for all responses
			for i := range survey.Responses { //loop all responses
				survey.Responses[i].Answer = append(survey.Responses[i].Answer, "No answer")
			}
		} else { //insert the new question in between
				temp := append([]Question{newQuestion}, survey.Questions[arrIndex:]...) //put the new question in front of the arrIndex question
				survey.Questions = append(survey.Questions[:arrIndex], temp...) //the temp arr is then appended back

				for i := range survey.Responses { //loop all responses
					tempResponse := append([]string{"No answer"}, survey.Responses[i].Answer[arrIndex:]...) //put the new question in front of the arrIndex question
					survey.Responses[i].Answer = append(survey.Responses[i].Answer[:arrIndex], tempResponse...) //the temp arr is then appended back
				}
		}

		survey.LastModifiedTime = time.Now().Format("2006-01-02 15:04:05")  //update the time of the survey last modified

		// update the survey in the database
		_, err = surveysCollection.UpdateOne(context.TODO(),
			bson.M{"token": token},
			bson.M{"$set": bson.M{"questions": survey.Questions, "lastModifiedTime": survey.LastModifiedTime, "responses": survey.Responses}}) //update the question arr which has one edited question
		if err != nil {
			c.JSON(500, gin.H{"error": "Failed to insert a question"})
			return
		}
		c.IndentedJSON(200, gin.H{"message": "The question is successfully inserted", "All Questions": survey.Questions})
	})

	//create a curl example token:5GXbe, adding a question between Q1 and Q2

	// curl -X POST http://localhost:8080/surveys/5GXbe/2 -H "Content-Type: application/json" -d '{"question":"What is your favourite color?", "question_format":"Multiple Choice", "specification":["red","blue","green"]}'

//delete a survey
	router.DELETE("/surveys/:token", func(c *gin.Context) {
		token := c.Param("token") // get the input token
		if checkToken(token,c) != nil {
			return
		}

		var survey Survey

		err := surveysCollection.FindOne(context.TODO(), bson.M{"token": token}).Decode(&survey) // search survey

		if err != nil {
			c.JSON(404, gin.H{"error": "Survey not found"})
			return
		}

		// Delete the survey from the db based on the token
		_, err = surveysCollection.DeleteOne(context.TODO(),bson.M{"token": token})

		if err != nil {
			c.JSON(500, gin.H{"error": "Failed to delete survey"})
			return
		}
		c.JSON(200, gin.H{"message": "Survey successfully deleted"})
	})

//delete a question
	router.DELETE("/surveys/:token/:questionNo", func(c *gin.Context) {
		token := c.Param("token") // get the input token
		if checkToken(token,c) != nil {
			return
		}

		var survey Survey
		err := surveysCollection.FindOne(context.TODO(), bson.M{"token": token}).Decode(&survey) // search survey
		if err != nil {
			c.JSON(404, gin.H{"error": "Survey not found"})
			return
		}

		questionNo, err := strconv.Atoi(c.Param("questionNo")) // get the question number string -> int
		if err != nil || questionNo < 0 || questionNo > len(survey.Questions) { //question should >= 1, question number should not exceed total no of questinos
			c.JSON(400, gin.H{"error": "Invalid question number"})
			return
		}

		arrIndex := questionNo - 1 //e.g. Q1 is at Questions[0]

		//delete Questions[arrIndex]
		_,err = surveysCollection.UpdateOne(context.TODO(), 
			bson.M{"token": token}, 
			bson.M{"$unset": bson.M{fmt.Sprintf("questions.%d", arrIndex): ""}}) // delete the question based on index			

		if err != nil {
			c.JSON(500, gin.H{"error": "Failed to delete the question"})
			return
		}

		//delete the null value in the array
		_, err = surveysCollection.UpdateOne(context.TODO(),
			bson.M{"token": token},
			bson.M{"$pull": bson.M{"questions": nil}})

		if err != nil {
			c.JSON(500, gin.H{"error": "Failed to delete the null value"})
			return
		}

		survey.LastModifiedTime = time.Now().Format("2006-01-02 15:04:05")  //update the time of the survey last modified

		//process the responses, if the question is deleted, the answer of this question will be deleted,and the rest of the answers will be shifted to the left
		for i := range survey.Responses { //loop all responses
			if arrIndex < len(survey.Responses[i].Answer) { //if the question is not the last question
				survey.Responses[i].Answer = append(survey.Responses[i].Answer[:arrIndex], survey.Responses[i].Answer[arrIndex+1:]...) //shift the answer to the left
			} else { //if the question is the last question
				survey.Responses[i].Answer = survey.Responses[i].Answer[:arrIndex] //delete the last answer
			}
		}

		_, err = surveysCollection.UpdateOne(context.TODO(),
			bson.M{"token": token},
			bson.M{"$set": bson.M{"lastModifiedTime": survey.LastModifiedTime, "responses": survey.Responses}}) //update the last modified time and responses
		if err != nil {
			c.JSON(500, gin.H{"error": "Failed to update the modified time/responses"})
			return
		}

		c.JSON(200, gin.H{"message": "The question is successfully deleted"})
	})

//submit a repsonse to a survey
	router.POST("/surveys/:token/responses", func(c *gin.Context) {
		token := c.Param("token") // get the input token
		if checkToken(token,c) != nil {
			return
		}

		var survey Survey

		err := surveysCollection.FindOne(context.TODO(), bson.M{"token": token}).Decode(&survey) // search survey
		if err != nil {
			c.JSON(404, gin.H{"error": "Survey not found"})
			return
		}

		var response Response
		if err := c.BindJSON(&response); err != nil {
			c.JSON(400, gin.H{"error": "Invalid input"})
			return
		}

		//get the current time, the format must be set to this one, else will not work
		response.Time = time.Now().Format("2006-01-02 15:04:05")

		if (len(response.Name) < 2) || (len(response.Name) > 100) { //response name should be 2 to 100 char
			c.JSON(400, gin.H{"error": "Your Name should be 2 to 100 characters"})
			return
		}

		//check no empty response
		if len(response.Answer) < 1 {
			c.JSON(400, gin.H{"error": "Not allow empty response"})
			return
		}

		//check the no of answers is eqal to no. of questions
		if len(response.Answer) != len(survey.Questions) {
			c.JSON(400, gin.H{"error": "Please answer the exact number of questions"})
			return
		}

		//check whether the answer algin with its specification?
		for i := range survey.Questions {
			if (survey.Questions[i].QuestionFormat == "Textbox" ) {
				if ((len(response.Answer[i]) < 1) || (len(response.Answer[i]) > 300)) { //answer should be 1 to 300 char
					c.JSON(400, gin.H{"error": "Answer should be 1 to 300 characters"})
					return
				}
			} else { //MC or Likert Scale, check the answer whether is one of the options?

				for j := range survey.Questions[i].Specification {
					if ((survey.Questions[i].Specification[j]) == (response.Answer[i])) { //is equal to one of the options
						break
					}
					if (j == len(survey.Questions[i].Specification)-1) { //if the answer is not in the options for last iteration
						currentQuestionNo := i + 1
						c.JSON(400, gin.H{"error": "Answer is not an option for question " + fmt.Sprint(currentQuestionNo)})
						return
					}
				}	
			} 
		}

		// appending the response to the survey
		_, err = surveysCollection.UpdateOne(context.TODO(), 
			bson.M{"token": token},
			bson.M{"$push": bson.M{"responses": response}})

		if err != nil {
			c.JSON(500, gin.H{"error": "Failed to submit reponse"})
			return
		}
		c.JSON(200, gin.H{"message": "Reponse successfully submitted"})
	})

//display responses of a survey
	router.GET("/surveys/:token/responses/:displayMode", func(c *gin.Context) {
		token := c.Param("token")
		if checkToken(token,c) != nil {
			return
		}

		var survey SurveyWithResponses

		err := surveysCollection.FindOne(context.TODO(), bson.M{"token": token}).Decode(&survey)
		if err != nil {
			c.JSON(404, gin.H{"error": "Survey not found"})
			return
		}

		if (len(survey.Responses) < 1) {
			c.JSON(404, gin.H{"error": "No response"})
			return
		}

		//displatMode = individual, show survey title + all responses based on responses  (Name + Question 1.title + Answer 1 + Question 2.title + Answer 2 +...+ Time, Other Name +...+ Time)
		//displayMode = overview, show the overview of all responses (Question 1 + ans1{each option count the no.,% } + Question 2 + ans 2 +...+) //hide response name for privacy

		displayMode := c.Param("displayMode")
		if (displayMode != "individual") && (displayMode != "overview") {
			c.JSON(400, gin.H{"error": "Invalid display mode"})
			return
		} else if displayMode == "individual" {
			var individualResponses []IndividualResponses
			for _, response := range survey.Responses {
				var qa []QuestionAnswer
				for i, question := range survey.Questions {

					//Fix out of index error, if the answer is not found, make it to be empty string (it happens when the response was submitted before adding more questions), it will be insert "No answer" for the new question as stated before
					var answer string
					if i < len(response.Answer) { //
						answer = response.Answer[i]
					} else { //question is more than answer
						answer = "" // make it to be empty string if the answer is not found
					}

					qa = append(qa, QuestionAnswer{
						Question: question.Question, // question title
						Answer: answer, //all answers
					})
				}
				individualResponses = append(individualResponses, IndividualResponses{
					Name: response.Name,
					QA: qa,
					Time: response.Time,
				})
			}
			formatted := FormattedIndividualResponses{
				Title:     survey.Title,
				Responses: individualResponses,
			}
			c.IndentedJSON(200, formatted)
			
		} else if displayMode == "overview" {
			var overviewQuestions []OverviewQuestions //used to store multiple questions with their answers+analysis
			for i, question := range survey.Questions {

				// Count responses for the current question.
				counts := make(map[string]int, len(question.Specification)) //create an empty map with key is answer options, and value is count

				for _, response := range survey.Responses {
					if i < len(response.Answer) {
						counts[response.Answer[i]]++ //e.g. {"red": 5, "blue": 8, "green": 1},response.Answer[i] is answer in response
					} else { //question is more than answer
						counts["No answer"]++
					}
				}

				total := len(survey.Responses) //total no. of responses
				var analysis []string //create a empty string array to store the answer and its count
				for answer, count := range counts { //optain the key-value pair in the map counts
					analysis = append(analysis, fmt.Sprintf("%s (%d, %.2f%%)", answer, count, float64(count)/float64(total)*100)) //e.g. "red[answer] (5[count], 33.33%[percentage count over total])"
				}
				overviewQuestions = append(overviewQuestions, OverviewQuestions{ 
					Question: question.Question,
					Answer:   analysis,
				})
			}
			formatted := FormattedOverviewResponses{
				Title: survey.Title,
				NumberOfResponses: len(survey.Responses),
				Questions: overviewQuestions,
			}
			c.IndentedJSON(200, formatted)
		}

		//old version
		//c.IndentedJSON(200, gin.H{"response": survey.Responses, "questions": survey.Questions , "number of responses": len(survey.Responses), "title": survey.Title})

	})

	router.Run() // run on port 8080

	// close the mongodb connection when the application stop
	defer func() {
		if err = client.Disconnect(context.TODO()); err != nil {
			log.Fatal(err)
		}
		fmt.Println("Connection to database is closed.")
	}()
}
